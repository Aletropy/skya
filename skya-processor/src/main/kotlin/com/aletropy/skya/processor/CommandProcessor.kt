package com.aletropy.skya.processor

import com.aletropy.skya.api.CommandsProvider
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo

class CommandProcessor(
	private val codeGenerator : CodeGenerator,
	private val logger : KSPLogger
) : SymbolProcessor
{
	override fun process(resolver: Resolver): List<KSAnnotated>
	{
		val symbols = resolver.getSymbolsWithAnnotation(CommandsProvider::class.qualifiedName!!)
		val validObjects = symbols.filterIsInstance<KSClassDeclaration>()
			.filter { it.classKind == ClassKind.OBJECT }
			.toList()

		if (validObjects.isNotEmpty()) {
			generateRegistry(validObjects)
		}

		return symbols.filterNot { it is KSClassDeclaration }.toList()
	}

	private fun generateRegistry(commandProviders: List<KSClassDeclaration>) {
		val packageName = "com.aletropy.skya.commands.generated"
		val fileName = "CommandsRegistry"

		val fileSpec = FileSpec.builder(packageName, fileName).apply {
			addFileComment("Generated by Skya's KSP Processor. DO NOT EDIT.")

			val objectBuilder = TypeSpec.objectBuilder(fileName)
			val registerFunction = FunSpec.builder("registerAll")
				.addParameter("registrar", ClassName("io.papermc.paper.command.brigadier", "Commands"))

			val commandNodeType = ClassName("com.mojang.brigadier.tree", "LiteralCommandNode")
			val commandSourceType = ClassName("io.papermc.paper.command.brigadier", "CommandSourceStack")
			val parameterizedCommandType = commandNodeType.parameterizedBy(commandSourceType)

			commandProviders.forEach { providerObject ->
				providerObject.getAllProperties()
					.filter { it.type.toTypeName() == parameterizedCommandType }
					.forEach { commandProperty ->
						registerFunction.addStatement("registrar.register(%T.%N)", providerObject.toClassName(), commandProperty.simpleName.asString())
						logger.info("Registered command property: ${providerObject.qualifiedName?.asString()}.${commandProperty.simpleName.asString()}")
					}
			}

			objectBuilder.addFunction(registerFunction.build())
			addType(objectBuilder.build())
		}.build()

		fileSpec.writeTo(codeGenerator, Dependencies(true, *commandProviders.mapNotNull { it.containingFile }.toTypedArray()))
	}
}

class CommandProcessorProvider : SymbolProcessorProvider {
	override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
		return CommandProcessor(environment.codeGenerator, environment.logger)
	}
}