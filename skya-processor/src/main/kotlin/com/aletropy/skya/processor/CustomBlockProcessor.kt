package com.aletropy.skya.processor

import com.aletropy.skya.api.RegisterBlock
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import kotlin.reflect.KClass

class CustomBlockProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger : KSPLogger
) : SymbolProcessor
{
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(RegisterBlock::class.qualifiedName!!)
        val validSymbols = symbols.filterIsInstance<KSClassDeclaration>().toList()

        if(validSymbols.isNotEmpty()) {
            generateRegistry(validSymbols)
        }

        return symbols.filterNot { it is KSClassDeclaration }.toList()
    }

    private fun generateRegistry(blocks : List<KSClassDeclaration>)
    {
        val packageName = "com.aletropy.skya.blocks.custom"
        val fileName = "CustomBlocks"

        val fileSpec = FileSpec.builder(packageName, fileName).apply {
            addFileComment("Generated by Skya's KSP Processor. DO NOT EDIT.")

            val objectBuilder = TypeSpec.objectBuilder(fileName)

            val blocksMapType =
                Map::class.asClassName().parameterizedBy(
                    String::class.asClassName(),
                    KClass::class.asClassName().parameterizedBy(WildcardTypeName.producerOf(
                        com.aletropy.skya.api.CustomBlock::class.asTypeName()
                    ))
                )
            val serializersMapType =
                Map::class.asClassName().parameterizedBy(
                    String::class.asClassName(),
                    ClassName("kotlinx.serialization", "KSerializer").parameterizedBy(WildcardTypeName.producerOf(ANY))
                )
            val namesMapType =
                Map::class.asClassName().parameterizedBy(
                    KClass::class.asClassName().parameterizedBy(WildcardTypeName.producerOf(
                        com.aletropy.skya.api.CustomBlock::class.asTypeName()
                    )),
                    String::class.asClassName()
                )

            val blocksProp = PropertySpec.builder("BLOCKS", blocksMapType)
            val serializersProp = PropertySpec.builder("SERIALIZERS", serializersMapType)
            val namesProp = PropertySpec.builder("NAMES", namesMapType)

            blocksProp.initializer(CodeBlock.builder().apply {
                addStatement("mapOf(")
                indent()
                blocks.forEach { block ->
                    val annotation = block.annotations.first {
                        it.shortName.asString() == "RegisterBlock"
                    }
                    val id = annotation.arguments.first {
                        it.name?.asString() == "id"
                    }.value as String
                    addStatement("%S to %T::class,", id, block.toClassName())
                }
                unindent()
                addStatement(")")
            }.build())

            serializersProp.initializer(CodeBlock.builder().apply {
                addStatement("mapOf(")
                indent()
                blocks.forEach { block ->
                    val annotation = block.annotations.first { it.shortName.asString() == "RegisterBlock" }
                    val id = annotation.arguments.first { it.name?.asString() == "id" }.value as String
                    val dataClass = annotation.arguments.first { it.name?.asString() == "dataClass" }.value as KSType

                    if (dataClass.declaration.simpleName.asString() != "Nothing") {
                        addStatement("%S to %T.serializer(),", id, dataClass.toClassName())
                    }
                }
                unindent()
                addStatement(")")
            }.build())

            namesProp.initializer(CodeBlock.builder().apply {
                addStatement("mapOf(")
                indent()
                blocks.forEach { block ->
                    val annotation = block.annotations.first { it.shortName.asString() == "RegisterBlock" }
                    val id = annotation.arguments.first { it.name?.asString() == "id" }.value as String
                    addStatement("%T::class to %S,", block.toClassName(), id)
                }
                unindent()
                addStatement(")")
            }.build())

            objectBuilder.addProperty(blocksProp.build())
            objectBuilder.addProperty(serializersProp.build())
            objectBuilder.addProperty(namesProp.build())

            addType(objectBuilder.build())
        }.build()

        fileSpec.writeTo(codeGenerator, Dependencies(true, *blocks.map { it.containingFile!! }.toTypedArray()))
    }
}

class CustomBlockProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return CustomBlockProcessor(environment.codeGenerator, environment.logger)
    }
}